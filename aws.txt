AWS TUTORIALS:
<--------IAM---------------->

1)Users: Users are persons identities used for accessing aws.
Groups: These are used to add multiple users in-order to attach same policies across multiple users.
Roles: These are used to assume identities which get temporary credentials to
the aws, which is used by aws resources,services,etc.
Policies: These specifies the permissible actions a user or a role can
perform. It is written in a JSON format.

2)Principle of least privilege is the way of giving the minimum access to the
user of role that they needed. It has to be followed that the identity which
has this policies won't be able to do anything apart form what they are
supposed to do. Which prevents from accidential actions.

3)Identity based policy: These are the policies which we attached to identities
such as Users, Groups, Roles.Which helps to specify the actions they can do
on the resources.
Resource based policy: These are the policies which we attaches to the aws
resources such as s3, SNS, lambda, etc.includes principal which specifies who
can access the resources.

4)AWS managed policies:
These are the policies maintained by aws itself.Also updated by AWS. We are
not able to edit the policies.
Customer managed policies:
These are the policies maintained by the aws users. We are fully able to edit
the policies.

5)MFA(Multi Factor Authenticator): Enabling this requires using an addition of
factor to authenticate while we are sign in or assume role.
Using MFA prevents misuse of our credential, even though the credentials got
stole.

6)Service linked roles:
These roles are predefined for certain services with specific trust
relationships. Which makes the role used by that service only.
Standard IAM role:
These roles are created by us, where we can define the trust and permissions.
Which are able to be used by all pricipals we specify.

7)Auditing IAM activity using cloudtrail:
Enable cloudtrail in aws account for all region.
Review cloudtrail event history for a certain history, events,etc.
Store cloudtrail logs in s3 , which helps us to audit logs using athena
We can set cloudwatch alarms for crtitical actions.


<-----------------EC2 & LAMBDA ----------------------->

1)INSTANCE TYPES AND DIFFERENCE:
General Purpose: Balanced compute, memory, networking. Suitable for web servers, small databases.
Compute Optimized: High CPU performance instances, used for compute intensive
tasks like batch operations, high performance applications, etc.
Memory Optimized: High memory to CPU ratio instances used for in memory databases, caching,
analytics, etc.
Storage Optimized: Instances with high sequential I/O and low-latency storage for databases and big data workloads.
Accelerated Computing :Instances with GPUs or special accelerators for ML, AI inference, HPC, graphics processing.

2)Key components of ASG:
Launch template/ Launch configuration: 
VPC subnets:
Desired, minimum , maximum capacity:
Scaling policies:
Health checks:

3)Scaling policies works when the specified capacity reaches. It either
increases the capacity or decreses the capacity as per the specification.
Types of scaling policies:
Target Tracking Scaling:
We specify some target like CPU-50%, so the ASG will maintain the total Usage
of CPU in the instances 50%.
Step Scaling:
Scaling happens in steps based on CloudWatch alarm thresholds.
Example: CPU > 70% → add 2 instances.

Simple Scaling:
One action per CloudWatch alarm.

4)Load Balancers:
Application load balancers:Layer 7, supports HTTPS and HTTP.Best of
microservices,path-host based mapping.
Network load balancer:Layer 4, TCP and UDP are supported. Best for ultra low
latency , real time traffic or high performance usages.
Gateway load balancer: For 3rd-party virtual appliances like firewalls/IDS/IPS 
Classic load balancer: Supports basic L4/L7 routing.Legacy type.

5)Application load balancer uses round robin algorithm to distribute traffics
among TGs. Which send traffic to each TG one by one, also to the healthy TGs
only.

6)A target group is a logical grouping of backend targets (EC2, IPs, Lambda).
ALB routes incoming requests to a specific target group based on your routing
rules (path/host).Each target group has its own health checks, so unhealthy instances are automatically removed from rotation.


7)We can configure host and path based routing in ALB listeners.
we are able to route a host (eg.demo.com) into a certain TG. Just like a path
(/images) into a certain TG.

8)Security Groups are statefull firewall attached to aws resources like EC2,
ALB, ENI, etc. Which handles the incoming anf outgoing of the traffic into
resources from certain ips.

9)NACL is stateless. while Security Groups are statefull. Which means if a
certain ip is able to go into a resource via SG, it can come out as the SG are
statefull. But in NACL, even if the traffic from an ip went into subnet, it
cannot come out with response unless we specifically allow outgoing as well,
as NACL is stateless.

10) In the SG we will open an inbound rule where the type of the port will be
22 (SSH) and insource range we will mention the ip range.

11) AWS will not allow us to delete an SG which is attached to a instance. We
can only delete an SG after detaching it from EC2. If we detaches and delete
the SG, the traffic rules we mentioned in the SG ont be able to communicate
with the ips.

12)EBS VOLUMES:
GP2&GP3: These are the deafult choice of EBS. Uses for boot
volumes,low-latency applications,etc.
io2/io1 (Provisioned IOPS SSD): High IOPS for databases like Oracle/SQL.
st1 (Throughput HDD): Big data, streaming workloads.
sc1 (Cold HDD): Infrequent access, archival.
magnetic: only for infrequently accessed workloads.

13)we can modify the size of the volume via cli or console. volume increases
instantly. we can use the growpart and resize2fs for extending the file
systems.

14)EBS snapshot is the point in time copy of EBS volume. We can store these
snapshots in s3 and vaults, which can be used for recovery and backups.

15)We can enable encrypt option while creating an EBS volume. If the volume is
already created as unencrypted, create a snap with it, and encrypt it while
creating a ebs volume with it.
Benfits of ebs encryption includes data in rest, transit will be encrypted.

16) EBS are block storages, used to attach to one instance at a time. 
EFS are file storage systems, used to attach multiple instances.

17)AWS Lambda lets run code without provisioning servers.You only pay for execution time.
AWS manages scaling, patching, and capacity.

18)Impacting factors:
Large package size
VPC-enabled Lambdas
Runtime type (Java/.NET slower vs Python/Node faster)
Provisioned concurrency not enabled

How to minimize:
Use smaller deployment packages
Prefer Python/Node runtimes (Lighter runtimes)
Enable Provisioned Concurrency
Use snapstart(Java runtimes)
Keep Lambda outside a VPC unless necessary 

19)A Savings Plan provides lower prices for EC2 usage in exchange for a 1–3
year commitment to a consistent hourly spend.

20)Compute savings plan: It is the savings plan which we get buy on certain
computation limit. It can cover instances, lambda computation costs.
EC2 instance saving plan: Its the plan which we buy on certain instance
family. 

21)Savings Plans are more flexible than Reserved Instances.
Reserved Instances are tied to specific instance types, sizes, regions.
Savings Plans apply automatically across workloads.


<----------EKS&ECR--------------------->

1)EKS core components:
->Control Plane:
API server:
etcd:
scheduler:
controller manager:
->Worker Nodes:
application pods:
kublet+kube-proxy
->Node Groups:
->Adds on/Plugins
VPC CNI plugin
kube proxy
CoreDNS

2)Each EKS node is launched inside a VPC subnet.
Pods receive ENIs and IP addresses from the VPC using the VPC CNI plugin.
Security Groups control traffic to nodes and the control plane.
Public subnets are used for internet-facing load balancers.
Private subnets are used for internal workloads.

3)Managed node groups:
This is managed and maintained by AWS, which includes the lifecycle,automatic
upgrades, fully automated provisioning,and health of node is also managed by
AWS.
Self managed node groups:
The users are responsible for the maintenance, upgrade, provisioning (script
or ASG), node health checks, etc.

4)Authentication:
IAM is used to authenticate users and roles via AWS IAM → Kubernetes API mapping.
This mapping is stored in the aws-auth ConfigMap.
Authorization:
After authentication, Kubernetes RBAC determines what the user can do.

IAM = WHO can access
RBAC = WHAT they can do 

5)High Availability:

Control plane is deployed across multiple Availability Zones automatically.
Worker nodes can be placed across multiple AZs.
Managed node groups maintain node health automatically.

Scaling:
Cluster Autoscaler → Scales worker nodes based on pending pods.
Horizontal Pod Autoscaler (HPA) → Scales pods based on CPU/memory/custom metrics.
Vertical Pod Autoscaler (VPA) → Adjusts pod resource requests.

6)LoadBalancer Service
Ingress + ALB Ingress Controller
NodePort Service

7)VPC CNI(Container Network Interface), which is providing ip to the pods.
Its important cause then only the pods will be able to directly use vpc
netowkring. reduce network hurdles and improve performance.

8)Kubernetes RBAC (Role-Based Access Control) defines permissions for users,groups, and service accounts.
It uses:
Roles → Namespace-level permissions
ClusterRoles → Cluster-wide permissions
RoleBindings / ClusterRoleBindings → Associate roles with users
In EKS, RBAC works together with IAM.
IAM authenticates → RBAC authorizes.

9)AWS VPC CNI (native, modern approach)
Enable network policy support in the VPC CNI add-on
Optionally enable strict mode
Apply standard Kubernetes NetworkPolicy objects
Enforcement happens using eBPF for high performance

Option 2: Third-party CNI like Calico
Deploy Calico
Use it to enforce Kubernetes NetworkPolicy
Useful for advanced or enterprise-grade policy features

10)ECR:
Fully managed, secure, private container registry by AWS.
Stores Docker/OCI images close to EKS/ECS environments.
Integrates with IAM for authentication.
Docker Hub is a general container registry which has certain pull limits while
aws doesnt have. We can access docker hub using username and password, while
ecr is accessible using iam.

11).ECR Private:
Our own private registry.
Access controlled via IAM.
Used for internal corporate images.
Images stored within our AWS account.

ECR Public:
Publicly accessible registry.
No authentication needed to pull images.
Used for distributing open-source or public container images.


<-----------------Route53----------------->

1)Amazon Route 53 is a highly available and scalable DNS and domain management service from AWS.
Key Features:
DNS service with global low-latency resolution
Domain name registration
Health checks & DNS failover
Traffic routing policies (weighted, latency-based, geolocation, failover,etc.)
Private DNS inside VPCs
Integration with AWS services like ALB, CloudFront, S3
100% availability SLA
It ensures reliable routing of user traffic to web applications.

2) A record type: Maps a domain name to an IPv4 address.
AAAA record type: Maps a domain name to an IPv6 address.
CAA record type: Specifies which certificate authorities (CAs) are allowed to issue SSL/TLS certificates for your domain.
CNAME record type: Maps one domain name to another domain name.
DS record type: Delegation Signer, used to establish a chain of trust for DNSSEC.
HTTPS record type: Modern record type that defines HTTPS or HTTP/3 service configurations,
MX record type: Specifies mail servers responsible for receiving email for the domain.
NAPTR record type: Used for advanced rewriting rules (mostly for VoIP, SIP,ENUM).
NS record type: Defines the authoritative name servers for a domain or zone.
PTR record type: Used in reverse DNS lookup.Maps an IP address back to a domain name.
SOA record type: Contains administrative information about a DNS zone,including:Primary name server,Admin email,Zone serial number,Refresh and retry intervals
SPF record type: A type of TXT record that specifies which mail servers are allowed to send emails on behalf of your domain.
SRV record type: Specifies the location of services (host + port).
SSHFP record type: Stores SSH public key fingerprints.
SVCB record type: A modern record type used to improve service discovery and enable HTTP/3 and encrypted DNS.
TLSA record type:Used with DNSSEC + TLS (DANE protocol).Specifies which TLS certificate or public key should be trusted for a domain.
TXT record type:Stores arbitrary text. Common uses:Domain verification (AWS, Google, etc.),SPF (as TXT),DKIM keys,Metadata or policy data

3)Public Hosted Zone:
Accessible on the internet
Used for public websites (example.com)
Private Hosted Zone:
Visible only inside one or more VPCs
Used for internal services (database, microservices)
Provides private DNS resolution

4)Route 53 supports multiple routing policies to control how traffic is
distributed:
-> Simple Routing
Single resource
Basic DNS response
No load balancing
-> Weighted Routing
Assign weight values to multiple endpoints
Used for A/B testing or gradual rollouts
-> Latency-based Routing
Sends users to the AWS region with lowest latency
Ideal for global applications
-> Geolocation Routing
Routes users based on their geographical location
Useful for compliance or localized content
-> Failover Routing
Primary → Secondary failover based on health checks
Used for disaster recovery
-> Multi-value Answer Routing
Returns multiple healthy IPs
Basic DNS-based load balancing

5)Alias Record (Route 53–specific):
Points a domain to AWS resources like:
ALB
CloudFront
S3 websites
API Gateway
Free of charge
Can be used at root domain (example.com)
CNAME Record:
Points a domain → another domain
Cannot be used at root domain
Standard DNS behavior

6)With Application Load Balancer (ALB):
Create an Alias record to the ALB DNS name
ALB IPs change dynamically → Alias automatically tracks it
With CloudFront:
Domain mapped to CloudFront distribution using CNAME or Alias
Often used for static + dynamic global content delivery
With S3 Static Websites:
Alias record pointing to S3 website endpoint
Used for hosting static sites
Route 53 ensures seamless routing to these AWS-managed endpoints.

7)Route 53 enables multi-region DR using:

-> Failover Routing
Primary Region = Active
Secondary Region = Standby
If health check fails, Route 53 routes traffic to DR region automatically

-> Latency-based Routing
Active/Active setup
Users routed to nearest healthy region
High performance and redundancy

-> Weighted Routing
Gradually shift traffic between regions
Useful during controlled failover testing

-> Health Checks
Continuously monitors endpoints
Automatically removes unhealthy endpoints from DNS responses

<-----------S3&CLOUDFRONT----------->
1)CloudFront is a Content Delivery Network (CDN) that caches S3 objects at edge
locations around the world.
How it works:
A user requests an object (image, video, file).
CloudFront checks the nearest edge location:
If cached → returns immediately (low latency).
If not cached → fetches from S3 (origin), caches it, and serves it.
Next users get the content directly from the cache.

2)An S3 bucket policy is a JSON document that defines permissions at the
bucket level.
To allow CloudFront to serve private S3 content, you attach a bucket policy
that grants access to:
Option 1: CloudFront Origin Access Identity (OAI)
You allow the OAI to read the S3 bucket.
Option 2: CloudFront Origin Access Control (OAC) (recommended)
OAC signs requests using SigV4 and is more secure.

3)Cloudfront supports caching and low latency deleivery, with private access
to the bucket using OAI or OAC.While S3 static web hosting doesnt support
caching, bucket has to be public.Uses only for static hosting for HTML,JS,CSS

4)How caching works:
CloudFront caches objects at edge locations.
Cache duration controlled by:
Cache-Control headers in S3
TTL settings in CloudFront behavior

Invalidating cached objects:
You can remove outdated cached content using a CloudFront invalidation.

5)Signed URLs and Signed Cookies provide controlled, time-limited access to
private content.
Signed URLs: Give temporary access to individual objects.
Signed Cookies: Provide access to multiple objects under a path or domain.

How they secure S3 content:
S3 bucket blocks direct public access.
CloudFront origin access ensures only CloudFront can read the bucket.
Signed URL/Cookies ensure only authorized users can access files through
CloudFront.

<-------------VPC----------------------->
1)Public Subnet:
Has a route to the Internet Gateway (IGW)
Resources can receive public IPs
Instances are reachable from the internet (if security groups allow)

Private Subnet:
No route to the Internet Gateway
Used for internal resources (DB, backend services)
Can access the internet only via NAT Gateway for outbound traffic
No public IP assigned

2)A route table defines how network traffic is routed within the VPC.

How it works:
Each subnet must be associated with one route table
Routes determine the destination (e.g., local VPC, IGW, NAT, TGW, Peering)
The “local” route is automatically added for VPC internal communication

Association:
A subnet can be associated with only one route table
A route table can be associated with multiple subnets

3)Internet Gateway enables communication between VPC resources and the public
internet.

IGW functions:
Provides a target for public subnets’ route tables
Performs NAT for instances with public IPs
Handles bi-directional internet traffic

To enable internet access:
Subnet route table must point to IGW
Instance must have a public IP or Elastic IP
Security groups allow outbound/inbound rules

4)NAT Gateway allows instances in private subnets to access the internet
Does NOT allow inbound traffic from the internet
Uses public IP but sits in a public subnet

IGW supports internet access for resources in public subnets, with inbound and
outbound traffic.While NATgateway is placed on public subnet, but used for the
outbound access for the resourcs in private subnet with outbound access.

5)VPC Peering connects two VPCs using private IPs
Traffic flows over AWS internal network
Low cost and simple configuration
No transitive routing (A → B → C not allowed)

When to use:
Small number of VPCs
Simple, low-latency communication
Direct connection between two VPCs

When NOT to use:
Large multi-VPC architectures
Need hub-and-spoke routing → use Transit Gateway

6)Yes, peering supports:
Cross-account
Cross-region

How:
VPC owner A sends a Peering Connection Request
VPC owner B accepts the request
Route tables must be updated on both sides
Security groups updated to allow inbound traffic from peer VPC
No overlapping CIDR ranges allowed.

7)Best practices:
Deploy NAT Gateway in each Availability Zone
Create separate private subnets per AZ, each routing to its local NAT
Avoid cross-AZ routing (extra charges + single point of failure)
Use NAT Gateway health checks implicitly done by AWS
Use AWS Backup or IaC to recreate NAT in case of issues

8)Route Table Security:
Ensure only public subnets route to IGW
Private subnets should use NAT Gateway
Avoid overly broad VPC Peering/TGW routes

NAT Gateway Security:
Use separate NAT per AZ
Inspect traffic using VPC Traffic Mirroring if needed
Do NOT expose NAT Gateway to inbound traffic

Internet Gateway Security:
Allow inbound only what is required in Security Groups
Route only public subnets to IGW
Avoid placing sensitive services in public subnets

General Best Practices:
Enable VPC Flow Logs
Use NACLs as an optional additional layer
Restrict Security Groups with least privilege rules

9)VPC Flow Logs capture network traffic information at the:
VPC level
Subnet level
ENI (instance) level

How they help troubleshoot:
Identify dropped packets (REJECT entries)
Check if traffic is reaching the instance
Verify security group or NACL blocking
Identify misconfigured routes
Detect abnormal traffic patterns
Inspect source/destination IPs and ports

Typical process:
Enable VPC Flow Logs for the ENI/subnet
Examine logs in CloudWatch or S3
Look for ACCEPT/REJECT and cause
Fix SG/NACL/route table accordingly

<--------------CLOUDWATCH&METRICS----------------->
1)CloudWatch Metrics:
Numerical data points collected from AWS services (e.g., EC2 CPU, disk I/O,
Lambda duration).
Updated at fixed intervals (1-minute or 5-minute).
Used to track resource performance and health.

CloudWatch Logs:
Stores application logs, system logs, VPC Flow Logs, Lambda logs, etc.
Supports log retention, filtering, and searching.
Used for debugging, auditing, and operational insights.

CloudWatch Alarms:
Watches a metric over time and triggers an action when a threshold is crossed.
Actions include SNS notifications, Auto Scaling actions, or EC2
stop/terminate/reboot.
Enables automated reaction to AWS events.

How they help:
Provide full visibility into AWS resource performance.
Detect abnormal behavior (high CPU, errors, latency).
Trigger automated responses to maintain system health.
Centralize logs for analysis and troubleshooting.

2)->Choose the Metric
Go to CloudWatch → Metrics → EC2 → Select CPUUtilization for the instance.
->Create an Alarm
Click Create Alarm.
Set threshold, e.g.:CPUUtilization > 80% for 5 minutes.

->Define the Alarm Condition
Example:
Statistic: Average
Period: 300 seconds
Threshold: > 80%

->Configure Actions
Choose what happens when alarm is triggered:
SNS Notification (email/SMS)
Auto Scaling action (trigger scale-out)
EC2 action (stop/terminate/reboot instance)

->Review and Create
Alarm switches to ALARM state when CPU exceeds threshold.
Action is executed automatically.

3)CloudWatch Logs Insights is an interactive log analysis tool that allows you to run fast,
SQL-like queries on your CloudWatch Logs. It helps to efficiently search, filter, and visualize large volumes of log data to
troubleshoot issues, find errors, analyze performance, and generate operational insights in seconds.
